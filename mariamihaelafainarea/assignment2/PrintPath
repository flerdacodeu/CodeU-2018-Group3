
import java.util.ArrayList;
import java.util.Stack;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author maria
 */
public class PrintPath<T> {  
    private Node first;
    //store the path in myStack
    private Stack<Node> myStack;

    public Node getFirst() {
        return first;
    }

    public void setFirst(Node first) {
        this.first = first;
    }
    
    public class Node {
        private T key;
        private Node left,right;

        public Node getRight() {
            return right;
        }

        public void setLeft(Node left) {
            this.left = left;
        }

        public void setKey(T key) {
            this.key = key;
        }

        public void setRight(Node right) {
            this.right = right;
        }

        public Node getLeft() {
            return left;
        }

        public T getKey() {
            return key;
        }
        
        public Node(T key, Node left, Node right) {
            this.key = key;
            this.left = left;
            this.right = right;
        }
    }
    private boolean pathExists (Node root,T x) {
        //this method go recursively
        //through the entire tree
        //and if it get to the wrong way
        //and doesn't find what is supposed
        //to find it stops with false.
        
        if (root == null) {
            return false;
        }
        //all the nodes will be stored in this way.
        //because i need to print the path from the
        //destination to the source
        myStack.add(root);
        if (root.key.equals(x)) {
            return true;
        } else {
            //use recursively the same function
            //to find in which direction my node is
            if (pathExists(root.left, x) || pathExists(root.right, x)) {
                return true;
            }
        }
        //the direction is not good
        myStack.pop();
        return false;
    }
 
    public ArrayList<Integer> testFunction(final T x) {
        //reinitialize the stack and
        //find if the node really exists in here
        myStack = new Stack<>();
        ArrayList<T> array = new ArrayList<>();
        if (pathExists(first, x)) {
            while(!myStack.empty()) {
                T value = myStack.pop().key;
                array.add(value);
                System.out.println(myStack.pop().key);
            }
        } else {
            System.out.println("There is no node like "+ x + " in here. Sorry!");
            return null;
        }
        return null;
    }
    public static void main(String[] args) {
        PrintPath<Integer> low = new PrintPath<Integer>();
        low.first = low.new Node(4, null, null);
        low.first.left = low.new Node(5, null, null);
        low.first.right = low.new Node(3, null, null);
        low.first.left.left = low.new Node(8, null, null);
        low.first.left.right = low.new Node(9, null, null);
        low.first.right.left = low.new Node(1, null, null);
        low.first.right.right = low.new Node(15, null, null);
        low.first.right.right.right = low.new Node(7, null, null);
        //             4
        //           /   \
        //          5     3
        //         / \   / \
        //        8   9 1   15
        //                   \
        //                    7
        //low.testFunction(5);
        //low.testFunction(7);
        //low.testFunction(9);
        //low.testFunction(15);
        //low.testFunction(1);
        low.testFunction(9);
    
    }
}
